print(x)
}
teste.formula = function(formula) {
if (class(x) != "formula")
stop("Not formula format")
print(formula)
}
teste = function(x,...) {
UseMethod("teste")
}
teste(1)
teste(data ~ frame)
teste.formula = function(formula) {
if (class(formula) != "formula")
stop("Not formula format")
print(formula)
}
teste(data ~ frame)
teste.formula = function(formula) {
if (class(formula) != "formula")
stop("Not formula format")
print("Using formula format")
print(formula)
}
teste = function(x,...) {
UseMethod("teste")
}
teste(data ~ frame)
teste.formula = function(formula) {
if (class(formula) != "formula"){
print ("Not formula")
stop("Not formula format")
}
print("Using formula format")
print(formula)
}
teste(data ~ frame)
teste(3)
teste("asas")
teste.default = function(x) {
print(x)
}
teste.formula = function(formula) {
print("Using formula format")
print(formula)
}
teste = function(x,...) {
UseMethod("teste")
}
teste("asas")
teste(23)
teste(data~frame)
library(ggplot2)
install.packages(c("fmsb", "ggplot2"))
RColorBrewer::brewer.pal.info
mock_data = data.frame(var1=rnorm(), row.names = NULL, check.rows = FALSE, check.names = TRUE, stringsAsFactors = default.stringsAsFactors())
randomValues = rbind(floor(runif(16)*100)+1, floor(runif(16)*20+5))
vals=apply(randomValues, 2, function(x) do.call(rnorm, as.list(c(100,x))))
attr1=as.vector(unlist(vals))
randomValues = rbind(floor(runif(16)*100)+1, floor(runif(16)*20+5))
vals=apply(randomValues, 2, function(x) do.call(rnorm, as.list(c(100,x))))
attr2=as.vector(unlist(vals))
randomValues = rbind(floor(runif(16)*100)+1, floor(runif(16)*20+5))
vals=apply(randomValues, 2, function(x) do.call(rnorm, as.list(c(100,x))))
attr3=as.vector(unlist(vals))
randomValues = rbind(floor(runif(16)*100)+1, floor(runif(16)*20+5))
vals=apply(randomValues, 2, function(x) do.call(rnorm, as.list(c(100,x))))
attr4=as.vector(unlist(vals))
randomValues = rbind(floor(runif(16)*100)+1, floor(runif(16)*20+5))
vals=apply(randomValues, 2, function(x) do.call(rnorm, as.list(c(100,x))))
attr5=as.vector(unlist(vals))
randomValues = rbind(floor(runif(16)*100)+1, floor(runif(16)*20+5))
vals=apply(randomValues, 2, function(x) do.call(rnorm, as.list(c(100,x))))
attr6=as.vector(unlist(vals))
mockData=data.frame(classes=as.factor(rep(1:16, each=100)), attr1=attr1, attr2, attr3, attr4, attr5, attr6)
head(mockData[,c(2, 1)])
ordem = order(as.vector(by(mockData$valores, mockData$classes,median)))
ordem
mockData=data.frame(classes=as.factor(rep(1:16, each=100)), attr1=attr1, attr2, attr3, attr4, attr5, attr6)
head(mockData[,c(2, 1)])
ordem = order(as.vector(by(mockData$valores, mockData$classes,median)))
mock_data = data.frame(var1=rnorm(), row.names = NULL, check.rows = FALSE, check.names = TRUE, stringsAsFactors = default.stringsAsFactors())
mock_data = data.frame(var1=rnorm(100), row.names = NULL, check.rows = FALSE, check.names = TRUE, stringsAsFactors = default.stringsAsFactors())
mock_data = data.frame(var1=rnorm(100), row.names = NULL, check.rows = FALSE, check.names = TRUE, stringsAsFactors = default.stringsAsFactors())
randomValues = rbind(floor(runif(16)*100)+1, floor(runif(16)*20+5))
vals=apply(randomValues, 2, function(x) do.call(rnorm, as.list(c(100,x))))
randomValues = rbind(floor(runif(16)*100)+1, floor(runif(16)*20+5))
vals=apply(randomValues, 2, function(x) do.call(rnorm, as.list(c(100,x))))
attr1=as.vector(unlist(vals))
randomValues = rbind(floor(runif(16)*100)+1, floor(runif(16)*20+5))
vals=apply(randomValues, 2, function(x) do.call(rnorm, as.list(c(100,x))))
attr2=as.vector(unlist(vals))
randomValues = rbind(floor(runif(16)*100)+1, floor(runif(16)*20+5))
vals=apply(randomValues, 2, function(x) do.call(rnorm, as.list(c(100,x))))
attr3=as.vector(unlist(vals))
randomValues = rbind(floor(runif(16)*100)+1, floor(runif(16)*20+5))
vals=apply(randomValues, 2, function(x) do.call(rnorm, as.list(c(100,x))))
attr4=as.vector(unlist(vals))
randomValues = rbind(floor(runif(16)*100)+1, floor(runif(16)*20+5))
vals=apply(randomValues, 2, function(x) do.call(rnorm, as.list(c(100,x))))
attr5=as.vector(unlist(vals))
randomValues = rbind(floor(runif(16)*100)+1, floor(runif(16)*20+5))
vals=apply(randomValues, 2, function(x) do.call(rnorm, as.list(c(100,x))))
attr6=as.vector(unlist(vals))
mockData=data.frame(classes=as.factor(rep(1:16, each=100)), attr1=attr1, attr2, attr3, attr4, attr5, attr6)
head(mockData[,c(2, 1)])
ordem = order(as.vector(by(mockData$valores, mockData$classes,median)))
ggplot(mockData, aes(y=valores, x=classes)) +
geom_boxplot() +
ylab("Values") +
xlab("Classes") +
scale_x_discrete(limits=ordem)
ggplot2::ggplot(mockData, aes(y=valores, x=classes)) +
geom_boxplot() +
ylab("Values") +
xlab("Classes") +
scale_x_discrete(limits=ordem)
library(ggplot2)
ggplot(mockData, aes(y=valores, x=classes)) +
geom_boxplot() +
ylab("Values") +
xlab("Classes") +
scale_x_discrete(limits=ordem)
mock_data = data.frame(var1=c(), row.names = NULL, check.rows = FALSE, check.names = TRUE, stringsAsFactors = default.stringsAsFactors())
randomValues = rbind(floor(runif(16)*100)+1, floor(runif(16)*20+5))
vals=apply(randomValues, 2, function(x) do.call(rnorm, as.list(c(100,x))))
attr1=as.vector(unlist(vals))
attr1
randomValues = rbind(floor(runif(16)*100)+1, floor(runif(16)*20+5))
vals=apply(randomValues, 2, function(x) do.call(rnorm, as.list(c(100,x))))
attr2=as.vector(unlist(vals))
randomValues = rbind(floor(runif(16)*100)+1, floor(runif(16)*20+5))
vals=apply(randomValues, 2, function(x) do.call(rnorm, as.list(c(100,x))))
attr3=as.vector(unlist(vals))
randomValues = rbind(floor(runif(16)*100)+1, floor(runif(16)*20+5))
vals=apply(randomValues, 2, function(x) do.call(rnorm, as.list(c(100,x))))
attr4=as.vector(unlist(vals))
randomValues = rbind(floor(runif(16)*100)+1, floor(runif(16)*20+5))
vals=apply(randomValues, 2, function(x) do.call(rnorm, as.list(c(100,x))))
attr5=as.vector(unlist(vals))
randomValues = rbind(floor(runif(16)*100)+1, floor(runif(16)*20+5))
vals=apply(randomValues, 2, function(x) do.call(rnorm, as.list(c(100,x))))
attr6=as.vector(unlist(vals))
mockData=data.frame(classes=as.factor(rep(1:16, each=100)), attr1=attr1, attr2, attr3, attr4, attr5, attr6)
ordem = order(as.vector(by(mockData$valores, mockData$classes,median)))
mockData$valores
mockData$classes
library(fmsb)
radoxplot(mockData, "classes")
radarchart(data.frame(v_count1=c(1), hue_mean=c(1), sat_mean=c(1), v_mean1=c(1), correlat_pc2=c(1), ratio1=c(2)
)
radarchart(data.frame(v_count1=c(1), hue_mean=c(1), sat_mean=c(1), v_mean1=c(1), correlat_pc2=c(1), ratio1=c(2)
), title="Pau-Brasil")
?data.frame
formula = classes ~ .
x = mockData
if (!inherits(formula, "formula"))
stop("method is only for formula objects")
m <- match.call(expand.dots = FALSE)
m
if (any(c("xtest", "ytest") %in% names(m)))
stop("xtest/ytest not supported through the formula interface")
names(m)[2] <- "formula"
if (is.matrix(eval(m$data, parent.frame())))
m$data <- as.data.frame(data)
names
names(m)
m$data
m$... <- NULL
m$na.action <- na.action
m[[1]] <- as.name("model.frame")
m <- eval(m, parent.frame())
formula
m[[1]]
formula = classes ~ .
m <- model.frame(terms(reformulate(attributes(Terms)$term.labels)),
data.frame(m))
Terms <- attr(m, "terms")
y <- model.response(m)
y
m$na.action <- na.action
m[[1]] <- as.name("model.frame")
m <- eval(m, parent.frame())
y <- model.response(m)
y
names(m)[2] <- "formula"
names(m)
if (is.matrix(eval(m$data, parent.frame())))
m$data <- as.data.frame(data)
m$... <- NULL
m
m$na.action <- na.action
m[[1]] <- as.name("model.frame")
m <- eval(m, parent.frame())
m$na.action <- na.action
m[[1]] <- as.name("model.frame")
m[[1]]
m
m <- eval(m, parent.frame())
if (!inherits(formula, "formula"))
stop("method is only for formula objects")
m <- match.call(expand.dots = FALSE)
if (any(c("xtest", "ytest") %in% names(m)))
stop("xtest/ytest not supported through the formula interface")
names(m)[2] <- "formula"
if (is.matrix(eval(m$data, parent.frame())))
m$data <- as.data.frame(data)
m$... <- NULL
m$na.action <- na.action
m[[1]] <- as.name("model.frame")
m <- eval(m, parent.frame())
parent.frame()
m
m$formula
m$formula = formula
formula
m <- eval(m, parent.frame())
m$data=data
m <- eval(m, parent.frame())
data
data = mockData
m <- eval(m, parent.frame())
m$data=data
m <- eval(m, parent.frame())
m$na.action <- na.action
m[[1]] <- as.name("model.frame")
m <- eval(m, parent.frame())
m
if (!inherits(formula, "formula"))
stop("method is only for formula objects")
formula = classes ~ .
data = mockData
m <- match.call(expand.dots = FALSE)
## Catch xtest and ytest in arguments.
if (any(c("xtest", "ytest") %in% names(m)))
stop("xtest/ytest not supported through the formula interface")
names(m)[2] <- "formula"
if (is.matrix(eval(m$data, parent.frame())))
m$data <- as.data.frame(data)
m$... <- NULL
m$na.action <- na.action
m[[1]] <- as.name("model.frame")
m <- eval(m, parent.frame())
m.formula
m$formula
m$data
radarBoxplot.default = function(x, y, ...) {
print(head(x))
print(head(y))
}
radarBoxplot.formula = function(formula, data, ...) {
### formula interface for radarBoxplot
### code gratefully stolen from randomForest.formula (package randomForest).
###
if (!inherits(formula, "formula"))
stop("method is only for formula objects")
m <- match.call(expand.dots = FALSE)
## Catch xtest and ytest in arguments.
if (any(c("xtest", "ytest") %in% names(m)))
stop("xtest/ytest not supported through the formula interface")
names(m)[2] <- "formula"
if (is.matrix(eval(m$data, parent.frame())))
m$data <- as.data.frame(data)
m$... <- NULL
m$na.action <- na.action
m[[1]] <- as.name("model.frame")
m <- eval(m, parent.frame())
y <- model.response(m)
Terms <- attr(m, "terms")
attr(Terms, "intercept") <- 0
attr(y, "na.action") <- attr(m, "na.action")
## Drop any "negative" terms in the formula.
m <- model.frame(terms(reformulate(attributes(Terms)$term.labels)),
data.frame(m))
## if (!is.null(y)) m <- m[, -1, drop=FALSE]
for (i in seq(along=m)) {
if (is.ordered(m[[i]])) m[[i]] <- as.numeric(m[[i]])
}
ret <- radarBoxplot.default(m, y, ...)
cl <- match.call()
cl[[1]] <- as.name("radarBoxplot")
ret$call <- cl
ret$terms <- Terms
if (!is.null(attr(y, "na.action"))) {
attr(ret$predicted, "na.action") <- ret$na.action <- attr(y, "na.action")
}
class(ret) <- c("radarBoxplot.formula", "radarBoxplot")
return(ret)
}
radarBoxplot(classes ~ ., mockData)
radarBoxplot = function(x, ...) {
UseMethod("radarBoxplot")
}
radarBoxplot(classes ~ ., mockData)
na.fail
radarBoxplot.formula = function(formula, data, ..., na.action=na.fail) {
### formula interface for radarBoxplot
### code gratefully stolen from randomForest.formula (package randomForest).
###
if (!inherits(formula, "formula"))
stop("method is only for formula objects")
m <- match.call(expand.dots = FALSE)
## Catch xtest and ytest in arguments.
if (any(c("xtest", "ytest") %in% names(m)))
stop("xtest/ytest not supported through the formula interface")
names(m)[2] <- "formula"
if (is.matrix(eval(m$data, parent.frame())))
m$data <- as.data.frame(data)
m$... <- NULL
m$na.action <- na.action
m[[1]] <- as.name("model.frame")
m <- eval(m, parent.frame())
y <- model.response(m)
Terms <- attr(m, "terms")
attr(Terms, "intercept") <- 0
attr(y, "na.action") <- attr(m, "na.action")
## Drop any "negative" terms in the formula.
m <- model.frame(terms(reformulate(attributes(Terms)$term.labels)),
data.frame(m))
## if (!is.null(y)) m <- m[, -1, drop=FALSE]
for (i in seq(along=m)) {
if (is.ordered(m[[i]])) m[[i]] <- as.numeric(m[[i]])
}
ret <- radarBoxplot.default(m, y, ...)
cl <- match.call()
cl[[1]] <- as.name("radarBoxplot")
ret$call <- cl
ret$terms <- Terms
if (!is.null(attr(y, "na.action"))) {
attr(ret$predicted, "na.action") <- ret$na.action <- attr(y, "na.action")
}
class(ret) <- c("radarBoxplot.formula", "radarBoxplot")
return(ret)
}
radarBoxplot(classes ~ ., mockData)
radarBoxplot.default = function(x, y, ...) {
print(head(x))
}
radarBoxplot(classes ~ ., mockData)
radarBoxplot.default = function(x, y, ...) {
print(head(y))
}
radarBoxplot(classes ~ ., mockData)
radarBoxplot.default = function(x, y, ...) {
y
}
radarBoxplot(classes ~ ., mockData)
radarBoxplot(classes ~ ., mockData)[0]
radarBoxplot(classes ~ ., mockData)[[0]]
y=radarBoxplot(classes ~ ., mockData)
head(y)
y$1
unlist(y)
as.vector(y)
as.vector(unlist(y))
as.vector(unlist(unlist(y)))
attr(y)
summary(y)
levels(y)
y=radarBoxplot(classes ~ ., mockData)
radarBoxplot.formula = function(formula, data, ..., subset, na.action=na.fail) {
### formula interface for radarBoxplot
### code gratefully stolen from randomForest.formula (package randomForest).
###
if (!inherits(formula, "formula"))
stop("method is only for formula objects")
m <- match.call(expand.dots = FALSE)
## Catch xtest and ytest in arguments.
if (any(c("xtest", "ytest") %in% names(m)))
stop("xtest/ytest not supported through the formula interface")
names(m)[2] <- "formula"
if (is.matrix(eval(m$data, parent.frame())))
m$data <- as.data.frame(data)
m$... <- NULL
m$na.action <- na.action
m[[1]] <- as.name("model.frame")
m <- eval(m, parent.frame())
y <- model.response(m)
Terms <- attr(m, "terms")
attr(Terms, "intercept") <- 0
attr(y, "na.action") <- attr(m, "na.action")
## Drop any "negative" terms in the formula.
m <- model.frame(terms(reformulate(attributes(Terms)$term.labels)),
data.frame(m))
## if (!is.null(y)) m <- m[, -1, drop=FALSE]
for (i in seq(along=m)) {
if (is.ordered(m[[i]])) m[[i]] <- as.numeric(m[[i]])
}
ret <- radarBoxplot.default(m, y, ...)
cl <- match.call()
cl[[1]] <- as.name("radarBoxplot")
ret$call <- cl
ret$terms <- Terms
if (!is.null(attr(y, "na.action"))) {
attr(ret$predicted, "na.action") <- ret$na.action <- attr(y, "na.action")
}
class(ret) <- c("radarBoxplot.formula", "radarBoxplot")
return(ret)
}
radarBoxplot.default = function(x, y, ...) {
y
}
radarBoxplot(classes ~ ., mockData)
y = radarBoxplot(classes ~ ., mockData)
y
unique(y)
y$levels
attr(y)
summary(y)
y == 1
unlist(y) == 1
str(unlist(y))
str(unlist(unlist(y))
)
str(unlist(unlist(unlist(y))))
str(numeric(unlist(unlist(unlist(y)))))
str(as.numeric(unlist(unlist(unlist(y)))))
str(as.number(unlist(unlist(unlist(y)))))
y = radarBoxplot(classes ~ ., mockData, na.action=na.omit)
y
y$1
y$'1'
y$'2'
y$'100'
y$'101'
y$call
y$call()
y$terms
y$terms[1]
y$terms[2]
y$terms[9]
y$terms[3]
y$terms[1]$"factors"
y$terms[1][1]
y$terms[1][1][1]
y$terms[1][[1]]
y$terms[1][[2]]
y$terms[1][[3]]
y$terms[1][[4]]
y$terms[[1]]
y$terms[[2]]
y$terms[[3]]
y$terms[[4]]
y$terms[[1]]
y$terms[[2]]
mockData[y$terms[[2]]]
mockData$y$terms[[2]]
mockData[,y$terms[[2]]]
y$terms[[2]]
mockData[,as.character(y$terms[[2]])]
is.factor(y)
classRF <- addclass || is.factor(y)
addclass <- is.null(y)
classRF <- addclass || is.factor(y)
classRF
!is.null(y)
length(unique(y))
unique(y)
length(y)
radarBoxplot = function(x, ...) {
UseMethod("radarBoxplot")
}
radarBoxplot.formula = function(formula, data, ..., subset, na.action=na.fail) {
### formula interface for radarBoxplot
### code gratefully stolen from randomForest.formula (package randomForest).
###
if (!inherits(formula, "formula"))
stop("method is only for formula objects")
m <- match.call(expand.dots = FALSE)
## Catch xtest and ytest in arguments.
if (any(c("xtest", "ytest") %in% names(m)))
stop("xtest/ytest not supported through the formula interface")
names(m)[2] <- "formula"
if (is.matrix(eval(m$data, parent.frame())))
m$data <- as.data.frame(data)
m$... <- NULL
m$na.action <- na.action
m[[1]] <- as.name("model.frame")
m <- eval(m, parent.frame())
y <- model.response(m)
Terms <- attr(m, "terms")
attr(Terms, "intercept") <- 0
attr(y, "na.action") <- attr(m, "na.action")
## Drop any "negative" terms in the formula.
m <- model.frame(terms(reformulate(attributes(Terms)$term.labels)),
data.frame(m))
## if (!is.null(y)) m <- m[, -1, drop=FALSE]
for (i in seq(along=m)) {
if (is.ordered(m[[i]])) m[[i]] <- as.numeric(m[[i]])
}
ret <- radarBoxplot.default(m, y, ...)
cl <- match.call()
cl[[1]] <- as.name("radarBoxplot")
ret$call <- cl
ret$terms <- Terms
if (!is.null(attr(y, "na.action"))) {
attr(ret$predicted, "na.action") <- ret$na.action <- attr(y, "na.action")
}
class(ret) <- c("radarBoxplot.formula", "radarBoxplot")
return(ret)
}
radarBoxplot.default = function(x, y, ...) {
y
}
y = radarBoxplot(classes ~ ., mockData, na.action=na.omit)
y
model.response(y)
model.frame(classes ~ ., mockData)
model.frame(classes ~ ., mockData)[,1]
model.frame(classes ~ ., mockData)[,2:]
model.response(classes ~ ., mockData)
model.extract(classes ~ ., mockData)
